{
  "hash": "feec44ab6dea6badccfb84e3b1dc0766",
  "result": {
    "engine": "knitr",
    "markdown": "---\nsubtitle: Einfache Vektordaten\n---\n\n\n# Übung 1 {#sec-uebung-1}\n\n## Vorbereitung \n\n\n- Erstelle ein neues ***RStudio Projekt***\n- Erstelle ein neues R-Script mit dem Namen `Uebung_1.R`\n- Lade dir `Vegauf_Aussenberg_2019_Kopfdaten.csv` (von Moodle, Kurstag 12) herunter \n\n## Übung 1.1 <!--10-->\n\n- Importiere die CSV `Vegauf_Aussenberg_2019_Kopfdaten.csv` gewohnt als `data.frame` in R. \n- Speichere die `data.frame` in der Variabel `ausserberg`\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg <- read.csv(\"data/original/Vegauf_Ausserberg_2019_Kopfdaten.csv\", sep = \"\\t\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg[1:6, 1:6] # ich zeige nur die ersten 6 Spalten und Zeilen\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Plot Verbuschung Vegetationstyp       Date geogr..Br. geogr..L.\n1 VS19_1   Verbuscht        Trocken 18.06.2019    2631210   1129910\n2 VS19_2 Unverbuscht    Halbtrocken 18.06.2019    2631175   1129752\n3 VS19_3   Verbuscht    Halbtrocken 19.06.2019    2631411   1129900\n4 VS19_4 Unverbuscht    Halbtrocken 18.06.2019    2631377   1129922\n5 VS19_5 Unverbuscht        Trocken 18.06.2019    2631324   1129816\n6 VS19_6 Unverbuscht        Trocken 19.06.2019    2631510   1129969\n```\n\n\n:::\n:::\n\n\n\n:::\n::::\n\n\n## Übung 1.2 <!--3-->\n\nSuch dir die Koordinaten im `data.frame` heraus. In welchem Koordinatensystem liegen diese wohl vor?\n\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\nIn CH1903+ LV95\n\n:::\n::::\n\n\n## Übung 1.3 <!--4-->\n\nVisualisiere die Erhebungsplots räumlich als Scatterplot. Die x- und y-Achsen sind jetzt räumliche Koordinaten, auf was musst du achten?\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ausserberg$geogr..Br., ausserberg$geogr..L., asp = 1)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-3-1.png){width=672}\n:::\n:::\n\n\nzu beachten:\n- Reihenfolge der Koordinaten\n- asp = 1\n\n\n\n:::\n::::\n\n\n\n\n## Übung 1.4 <!--3-->\n\nInstalliere nun das R-Package `sf` und lade es in die aktuelle Session.\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"sf\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"sf\")           \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to GEOS 3.12.0, GDAL 3.7.1, PROJ 9.2.1; sf_use_s2() is TRUE\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n\n\n\n## Übung 1.5 <!--5-->\n\nWir machen nun aus dem `data.frame` `ausserberg` ein Vektor-Objekt und verwenden dazu die Funktion `st_as_sf()` aus der eben installierten Library `sf`. \n\nMit dem Argument `coords = ` informieren wir dieser Funktion, wo unsere Koordinateninformation liegt. Probiere etwas rum bis es funktioniert und weise *danach* das Neue Objekt der Variabel `ausserberg_sf` zu.\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg_sf <- st_as_sf(ausserberg, coords = c(\"geogr..Br.\",\"geogr..L.\"))\n```\n:::\n\n\n\n:::\n::::\n\n\n## Übung 1.6 <!--2-->\n\n\nVergleiche nun `ausserberg` und `ausserberg_sf` in der Konsole. Wodurch unterscheiden sie sich?\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n- `ausserberg_sf`: hat die beiden Koordinaten-Spalten verloren und verfügt dafür neu über eine Spalte `geometry`.\n- `ausserberg_sf`: verfügt nun über Metadaten im header:\n\n```default\nSimple feature collection with 15 features and 34 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2631175 ymin: 1129737 xmax: 2631510 ymax: 1129986\nCRS:           NA\n```\n\n:::\n::::\n\n\n*Wir haben nirgends deklariert, in welchem Koordinatenbezugssystem sich unsere Koordinaten befinden.*\n\n\n\n## Input CRS ansprechen<!--6-->\n\nNun wollen wir unserem Datensatz das richtige Koordinatenreferenzsystem zuweisen. Wie sprechen wir das korrekte Koordinatensystem `CH1903+ LV95` an?\n\nIm Wesentlichen gibt es 3 Methoden, ein Koordinatenreferenzsystem anzusprechen: \n\n- proj.4\n- Well known text wkt\n- EPSG\n\n\n\n:::{.callout-note collapse=\"true\"}\n\n## proj.4 (optional)\n\n- In einem `proj.4`-string werden alle wichtige Aspekte des Koordinatenreferensystems abgespeichert (ellipse, datum, projection units)\n- der `proj.4`-strings verwenden ein `key=value` system, die mit `+` kombiniert werden\n- der `proj.4`-string von `CH1903+LV95` sieht folgendermassen aus: \n\n```{.default}\n+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 \n+x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 \n+units=m +no_defs\n```\n\n:::\n\n\n:::{.callout-note collapse=\"true\"}\n\n## Well known text wkt (optional)\n\n- Logik ähnlich wie `proj.4`-strings\n- verwenden einen anderen Syntax (`key[value]`)\n- der wkt von `CH1903+LV95` sieht folgendermassen aus\n\n```{.default}\nPROJCS[\"CH1903+ / LV95\",\n    GEOGCS[\"CH1903+\",\n        DATUM[\"CH1903+\",\n            SPHEROID[\"Bessel 1841\",6377397.155,299.1528128,\n                AUTHORITY[\"EPSG\",\"7004\"]],\n            TOWGS84[674.374,15.056,405.346,0,0,0,0],\n            AUTHORITY[\"EPSG\",\"6150\"]],\n        PRIMEM[\"Greenwich\",0,\n            AUTHORITY[\"EPSG\",\"8901\"]],\n        UNIT[\"degree\",0.0174532925199433,\n            AUTHORITY[\"EPSG\",\"9122\"]],\n        AUTHORITY[\"EPSG\",\"4150\"]],\n    PROJECTION[\"Hotine_Oblique_Mercator_Azimuth_Center\"],\n    PARAMETER[\"latitude_of_center\",46.95240555555556],\n    PARAMETER[\"longitude_of_center\",7.439583333333333],\n    PARAMETER[\"azimuth\",90],\n    PARAMETER[\"rectified_grid_angle\",90],\n    PARAMETER[\"scale_factor\",1],\n    PARAMETER[\"false_easting\",2600000],\n    PARAMETER[\"false_northing\",1200000],\n    UNIT[\"metre\",1,\n        AUTHORITY[\"EPSG\",\"9001\"]],\n    AXIS[\"Y\",EAST],\n    AXIS[\"X\",NORTH],\n    AUTHORITY[\"EPSG\",\"2056\"]]\n```\n\n:::\n\n\n:::{.callout-important collapse=\"true\"}\n\n## EPSG Code (wichtig)\n\n- die European Petroleum Survey Group (EPSG): ein wissenschaftliche Organisation (Geodäsie, Vermessung und Kartographie)\n\n- öffentliche Datenbank um Koordinatenbezugssysteme (sowie Ellipsoide und Geodätisches Datumsangaben) festzuhalten\n- jede Einträge hat einen Referenz Code (siehe [epsg.io](https://epsg.io/))\n-  Wie lautet der EPSG Code für `CH1903+LV95`?\n- der EPSG Code ist der einfachste Weg, ein Koordinatenbezugssystem anzusprechen\n- am besten ist, man notiert sich die EPSG Codes unserer wichtigsten Koordinatenbezugssysteme:\n\n  | Koordinatenbezugssystem   | EPSG Code   | Kommentar                           | Einheit |\n  |---------------------------|-------------| ------------------------------------|---------|\n  | `CH1903+ LV95`            | `2056`      | Neues Koordinatensystem der Schweiz | Meter   |\n  | `CH1903 LV03`             | `21781`     | Altes Koordinatensystem der Schweiz | Meter   |\n  | `WGS84`                   | `4326`      | Weltweites Koordinatensystem        | Grad    |\n\n\n\n:::\n\n\n\n## Übung 1.8 <!--3-->\n\nWeise nun unserem Datensatz das richtige Koordinatensystem zu. Dafür brauchst du die Funktion `st_crs` sowie den EPSG Code des Koordinatensystems. \n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(ausserberg_sf) <- 2056\n\nausserberg_sf[1:4, 1:6] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 4 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2631175 ymin: 1129752 xmax: 2631411 ymax: 1129922\nProjected CRS: CH1903+ / LV95\n    Plot Verbuschung Vegetationstyp       Date Genauigkeit Meereshoehe\n1 VS19_1   Verbuscht        Trocken 18.06.2019           5        1298\n2 VS19_2 Unverbuscht    Halbtrocken 18.06.2019           5        1263\n3 VS19_3   Verbuscht    Halbtrocken 19.06.2019          10        1282\n4 VS19_4 Unverbuscht    Halbtrocken 18.06.2019           3        1295\n                 geometry\n1 POINT (2631210 1129910)\n2 POINT (2631175 1129752)\n3 POINT (2631411 1129900)\n4 POINT (2631377 1129922)\n```\n\n\n:::\n:::\n\n\n```\nSimple feature collection with 15 features and 34 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2631175 ymin: 1129752 xmax: 2631210 ymax: 1129910\nProjected CRS: CH1903+ / LV95\n```\n\n\n:::\n::::\n\n\n\n## Übung 1.9 <!--2-->\n\n- `R` weiss nun, das es sich bei `aussenberg_sf`um einen Vektordatensatz handelt \n- `aussenberg_sf` reagiert nun anders auf gewisse functions\n- teste die Funktion `plot` mit `aussenberg_sf`\n\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot(ausserberg_sf) <- macht einen Plot pro Spalte, maximal 9\nplot(ausserberg_sf[\"Verbuschung\"]) # Plottet nur die ausgewählte Spalte\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-10-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n\n\n## Input `tmap` <!--6-->\n\n- In `R` gibt es dezidierte libraries, um geografische Daten zu visualisieren\n- Wir werden im Unterricht die library `tmap` verwenden. \n- Installiere dieses Package und lade es in die aktuelle session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tmap\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tmap\")\n```\n:::\n\n\n\n\n\n- `tmap` funktioniert nach einem \"layer\"-Prinzip\n- ein Layer besteht aus 2 Komponenten: \n  - `tm_shape()`: der Datensatz\n  - `tm_dots` (oder `tm_lines`, `tm_polygons`...):  die *Darstellungsform*\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) + # datensatz        \n  tm_dots()               # darstellungsform \n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +  \n  tm_bubbles()            \n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-2.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +\n  tm_bubbles(col = \"Verbuschung\")\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-3.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +\n  tm_bubbles(col = \"Verbuschung\",\n             shape = \"Vegetationstyp\")\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-4.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +\n  tm_bubbles(col = \"Verbuschung\",\n             shape = \"Vegetationstyp\") +\n  tm_layout(legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-5.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +\n  tm_bubbles(col = \"Verbuschung\",\n             shape = \"Vegetationstyp\") +\n  tm_layout(legend.outside = TRUE,\n            legend.position = c(\"right\",\"bottom\"))\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-6.png){width=672}\n:::\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +\n  tm_bubbles(col = \"Verbuschung\",\n             shape = \"Vegetationstyp\") +\n  tm_layout(legend.outside = TRUE,\n            legend.position = c(\"right\",\"bottom\")) +\n  tm_grid(labels.rot = c(90, 0), lines = FALSE)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-13-7.png){width=672}\n:::\n:::\n\n\n\n\n## Übung 1.10 <!--7-->\n\nErstellt nun eine eigene Karte mit `tmap` und euren Daten. Versucht, den unten stehenden Plot zu rekonstruieren (oder probiert was eigenes). \n\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf) +\n  tm_bubbles(col = \"gew_Temperaturzahl\", palette = \"viridis\") +\n  tm_layout(legend.outside = TRUE,\n            legend.position = c(\"right\",\"bottom\")) +\n  tm_grid(labels.rot = c(0, 90), \n          lines = FALSE)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-28-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n\n\n\n\n## Input CRS wechseln <!--4-->\n\n- Bisher: Dem Datensatz ein Koordinatensystem *zuweisen*. \n- Auch häufig: Koordinaten vom einen Koordinantensystem in ein anderes übersetzen (*transformieren*)\n- Wichtig unterschied!\n- Koordinatenbezugssystem *zuweisen* \n  - verändert die Koordinatenwerte *nicht*, \n  - ist nur sinnvoll, wenn das Koordinatensystem nicht oder falsch zugewiesen wurde\n- Koordinatenbezugssystem*transformieren* \n  - verändert die Koordinatenwerte \n  - ist unter verschiedenen Szenarien sinnvoll (um versch. Datequellen zu integrieren)\n\n\n\n\n## Übung 1.11 <!--3-->\n\n- Transformiert `ausserberg_sf` in das Koordinatenbezugssystem WGS84\n- Speichert den output in einer neuen Variabel (z.B `ausserberg_sf_wgs84`)\n- Schaut euch diesen Datensatz an, was hat sich verändert?\n- Tipp: Nutzt dafür die Funktion `st_transform()`\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg_sf_wgs84 <- st_transform(ausserberg_sf, 4326)\n```\n:::\n\n\nDie Metadaten haben sich verändert (vorher: `Projected CRS: CH1903+ / LV95`)\n```\nSimple feature collection with 15 features and 34 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 7.843394 ymin: 46.3183 xmax: 7.847758 ymax: 46.32055\nGeodetic CRS:  WGS 84\n```\n\nZudem haben sich die Koordinatenwerte verändert. Neu: `POINT (7.843859 46.31987)`\n\n\n:::\n::::\n\n\n## Übung 1.12 (Optional) <!--3-->\n\nWiederhole nochmal den letzten `tmap` plot , diesmal mit dem Datensatz `ausserberg_sf_wgs84`. Wie unterscheiden sich die Plots? \n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(ausserberg_sf_wgs84) +\n  tm_bubbles(col = \"gew_Temperaturzahl\", palette = \"viridis\") +\n  tm_layout(legend.outside = TRUE,\n            legend.position = c(\"right\",\"bottom\")) +\n  tm_grid(labels.rot = c(0, 90), \n          lines = FALSE)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-30-1.png){width=672}\n:::\n:::\n\n\n- Die markierten Koordinaten haben sich verändert\n- Kaum merklich haben sich auch die Positionen der Punkte verändert (unterschiedliches Datum)\n\n\n:::\n::::\n\n\n\n\n## Input Räumliche Datenformate<!--4-->\n\n- CSVs eignen sich nur bedingt um räumliche Daten abzuspeichern\n- Um aus `Vegauf_Ausserberg_2019_Kopfdaten.csv` ein räumliches Objekt zu machen mussten wir verschiedene Schritte erledigen\n  1. CSV als Dataframe einlesen\n  2. CSV in `sf` objekt konvertieren\n  3. CRS Zuweisen\n- Wir können `ausserberg_sf` in einem explizit *räumlichen* Datenformat abspeichern, sodass die obigen Schritte beim importieren nicht nötig sind:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_sf(ausserberg_sf, \"data/processed/ausserberg.gpkg\")\n```\n:::\n\n\n\nBeim Einlesen von `ausserberg.gpkg` ist R nun sofort klar, dass es sich um Punktdaten im Koordinatenbezugssystem `EPSG 2056` handelt. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg_sf <- read_sf(\"data/processed/ausserberg.gpkg\")\n```\n:::\n\n\n\n\n\n\n## Übung 1.13 <!--15-->\n\n- Importiere nun aus dem Excel Hagenmoos.xlsx das Datenblatt `KopfdatenVertikal` als `data.frame`. \n- Konvertiere den Dataframe in ein `sf` objekt \n- Weise das korrekte Koordinatensytem zu\n- Transformiere die Koordinaten anschliessend in WGS84\n- erstelle eine Karte mit `tmap`\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhangenmoos <- readxl::read_excel(\"data/original/daten_vegedaz/Hagenmoos.xlsx\", \"KopfdatenVertikal\")\n\nhangenmoos_sf <- st_as_sf(hangenmoos, coords = c(\"X\", \"Y\"))\nst_crs(hangenmoos_sf) <- 21781\n\nhangenmoos_sf_wgs84 <- st_transform(hangenmoos_sf, 4326)\n\ntm_shape(hangenmoos_sf_wgs84) +\n  tm_bubbles(col = \"Bereich\")  +\n  tm_layout(legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-34-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n\n\n\n\n## Input Small Multiples<!--3-->\n\n- Der Datensatz `Hangenmoos` beinhaltet Erhebungen an den gleichen Standorten in verschiedenen Jahren. \n- Dies führt dazu, dass sich Punkte überlagern (gleiche Koordinaten)\n- Um dies zu vermeiden, können wir mit der `facet` option in `tmap` arbeiten\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hangenmoos_sf_wgs84) +\n  tm_bubbles(size = .2, col = \"Bereich\")  +\n  tm_layout(legend.outside = TRUE) +\n  tm_facets(\"Jahr\",nrow = 1)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/uebung-1-35-1.png){width=672}\n:::\n:::\n\n\n\n\n## Übung 1.14 <!--3-->\n\n\n- Bisher haben wir nur s\n- Mit `tmap` lassen sich aber auch sehr leicht interaktive Karten erstellen\n- Setze dafür `tmap_mode(\"view\")` und führe dein letzter Code für die Erstellung eines tmap-Plots nochmals aus\n  \n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hangenmoos_sf_wgs84) +  tm_bubbles(col = \"Bereich\")  +  tm_layout(legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](uebung_1_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n\n## Fazit\n\n\n:::{.callout-note}\n\n## Rückblick <!-- -->\n\n- Bisher haben wir mit Vektordaten vom Typ `Point` gearbeitet\n- Das dem zugrundeliegende, konzeptionelle Datenmodell ist das Entitäten Modell\n- Diese Punktdaten waren in einem csv sowie einem xlsx Dateiformat abgespeichert\n- In `R` haben wir diese Punktdaten als `data.frame` importiert und danach in ein `sf` Objekt konvertiert\n- `sf`-Objekte zeichnen sich dadurch aus, dass sie über eine Geometriespalte sowie über Metadaten verfügen\n\n:::\n\n\n:::{.callout-note}\n## Ausblick\n\n- Punktdaten lassen sich gut in CSV abspeichern, weil sich die Geometrie so gut vorhersehbar ist (jeder Punkte besteht aus genau einer x- und einer y-Koordinate)\n- Linien und Polygone sind komplexer, sie können aus beliebig vielen Knoten bestehen\n- Es bessere Wege, räumliche Daten abzuspeichern\n- Das bekannteste Format für Vektordaten ist das *shapefile*\n- Shapefiles haben aber Nachteile ein sinnvolleres Format ist deshalb *geopackage*\n\n:::\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "uebung_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}