{
  "hash": "bfc56a39135f7c8eb5339de9a28b9f39",
  "result": {
    "engine": "knitr",
    "markdown": "---\nsubtitle: Integration von Geodaten\n---\n\n\n# Übung 5 {#sec-uebung-5}\n\n- Bisher haben wir alle Datensätze einzeln betrachtet\n- Wenn wir alle Datensätze ins gleiche Bezugssystem bringen, können wir diese *integrieren* bzw. überlagern\n- Überlagern kann heissen: \n  - gemeinsam visualisieren\n  - Information übertragen\n\n\nVorbereitung: \n\n- Starte ein neues Script `Uebung_5.R`\n- Importiere darin alle räumlichen libraries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tmap\")\nlibrary(\"sf\")\nlibrary(\"terra\")\n\n# tmap_options(check.and.fix = TRUE)\ntmap_mode(\"plot\")\n```\n:::\n\n\n\n\n\n## Übung 5.1\n\nImportiere die Datensätze `ausserberg.gpkg` (aus Übung 2) sowie `dhm200_2056.tif` (aus Übung 3, `data-processed/ausserberg.gpkg` bzw. `data-processed/dhm200_2056.tif`)\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg <- read_sf(\"data-processed/ausserberg.gpkg\")\ndhm200 <- rast(\"data-processed/dhm200_2056.tif\")\n```\n:::\n\n\n\n\n:::\n::::\n\n## Übung 5.2\n\nÜberlagere die beiden Datensätze in einem `tmap`-Plot, indem du diese mit `+` verkettest.\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm200) + \n  tm_raster() + \n  tm_shape(ausserberg) + \n  tm_dots()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nstars object downsampled to 1299 by 770 cells. See tm_shape manual (argument raster.downsample)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-3-1.png){width=672}\n:::\n:::\n\n\n- da das `dhm200` die ganze Schweiz abdeckt, sind unsere Punkte kaum erkennbar.\n- Lösung: raster mittels unseren Punktdaten \"zuschneiden\" (`crop`)\n\n\n:::\n::::\n\n## Übung 5.3\n\n- Mit `crop()` können wir ein Raster auf den \"extent\" von einem Vektor Datensatz zuschneiden\n- Schneide `dhm200` auf den extent von `ausserberg` zu\n- Visualisiere das resultierende Raster mit `tmap` (wieder gemeinsam mit `ausserberg`)\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndhm200_cropped <- terra::crop(dhm200, ausserberg)\n\ntm_shape(dhm200_cropped) + \n  tm_raster() + \n  tm_shape(ausserberg) + \n  tm_dots() +\n  tm_layout(legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-4-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n::::\n\n\n\n## Übung 5.4\n- die Auflösung des Raster Datensatzes ist zu grob!!\n- Lösung: Hoch aufgelöster Datensatz `dhm25` (aus Übung 4) und einlesen (zip-File: `processed/dhm25_2056.tif`)\n- wiederhole das Zuschneiden mittels `crop` sowie das Visualisieren mittels `tmap`\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndhm25 <- rast(\"data-processed/dhm25_2056.tif\") \ndhm25_crop <- crop(dhm25, ausserberg)           \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm25_crop) + \n  tm_raster(style = \"cont\", palette = \"viridis\") + \n  tm_shape(ausserberg) + \n  tm_dots()\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-6-1.png){width=672}\n:::\n:::\n\n\n\n\n\n:::\n::::\n\n\n## Input: Rasterwerte extrahieren\n\n\n- bisher haben wir zwei Datensätze (Raster und Vektor) visuell überlagert\n- nächster Schritt: **Information** von Raster → Punkt Datensatz übertragen\n- dazu müssen wir `ausserberg` von einem `sp`- in ein `SpatVector` Objekt konvertieren\n- danach können wir das `SpatVector` Objekt gemeinsam mit `extract` verwenden\n\n\n\n## Übung 5.5\n\n- Verwende die Funktion `extract` mit `ausserberg` um die Höhenwerte aus `dhm25` zu extrahieren\n- Speichere den output in einer Variabel und beguteachte diese\n\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev <- extract(dhm25, ausserberg) # <- die Funktion extract() extrahiert die Information\n\nelev                               # <- der output ist eine data.frame mit 2 Spalten\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   ID dhm25_grid_raster\n1   1          1307.219\n2   2          1269.035\n3   3          1284.346\n4   4          1292.309\n5   5          1282.125\n6   6          1281.335\n7   7          1320.213\n8   8          1292.845\n9   9          1267.855\n10 10          1307.206\n11 11          1277.758\n12 12          1281.398\n13 13          1287.539\n14 14          1244.080\n15 15          1294.878\n```\n\n\n:::\n:::\n\n\n\n:::\n::::\n\n\n## Übung 5.6\n\nSpiele die Höheninformation aus `extract` zurück in `ausserberg`.\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nausserberg$elevation <- elev[,2]         # <- die 2. Spalte aus elev auf ausserberg übertragen\n```\n:::\n\n\n\n\n:::\n::::\n\n  ## Übung 5.7 \n\nVisualisiere nun `ausserberg` und Färbe die Punkte nach ihrer Höheninformation ein.\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(dhm25_crop) + \n  tm_raster(style = \"cont\", palette = \"viridis\") + \n  tm_shape(ausserberg) + \n  tm_bubbles() +\n  tm_layout(title = \"dhm25 mit überlagerten Punktdaten\")\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(ausserberg) + \n  tm_bubbles(col=\"elevation\", style=\"cont\", palette=\"viridis\", breaks = seq(1240, 1320, 20)) +\n  tm_layout(title = \"Punkdaten mit extrahierten Werten aus dhm25\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Values have found that are higher than the highest break\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-11-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n::::\n\n\n## Input: Vektordaten zuschneiden\n\n- nun wollen wir zwei Vektordatensätze miteinander verschneiden\n- Ausgangslage:\n  - wir verfügen über einen TWW Datensatz der Schweiz\n    - URL: {{< var datasets.tww.url >}})\n    - Shorturl: {{< var datasets.tww.shorturl >}}\n  - wir verfügen über den Gemeindelayer der Schweiz\n    - URL: {{< var datasets.swissboundaries3d.url >}})\n    - Shorturl: {{< var datasets.swissboundaries3d.shorturl >}})\n  - wir wollen alle TWW Flächen innerhalb der Gemeinde Landquart erhalten\n\n\n\n## Übung 5.8\n\n- Lade diese beiden Datensätze herunter und importiere sie in `R` (swissboundaries *Hoheitsgebiet*)\n- Transformiere sie in `ESPG 2056`\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Datensätze einlesen:\ntww <- read_sf(\"data-original/TWW/TWW_LV95/trockenwiesenweiden.shp\")\nhoheitsgebiet <- read_sf(\"data-original/ch.swisstopo.swissboundaries3d-gemeinde-flaeche.fill/swissBOUNDARIES3D_1_3_TLM_HOHEITSGEBIET.shp\")\n\n# Gemeindegrenzenen in EPSG 2056 transformieren und nur Landquart selektieren\nhoheitsgebiet <- st_transform(hoheitsgebiet, 2056)\n```\n:::\n\n\n\n\n:::\n::::\n\n## Übung 5.9\n\nErstelle ein neues Objekt `landquart`, welches nur die Gemeinde Landquart beinhaltet und visualisiere diese.\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlandquart <- hoheitsgebiet[hoheitsgebiet$NAME == \"Landquart\", ]\n\ntm_shape(landquart) + \n  tm_polygons() +\n  tm_layout(title = \"Gemeinde Landquart\")\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-13-1.png){width=672}\n:::\n:::\n\n\n:::\n::::\n## Übung 5.10\n\nÜberlagere die `TWW` Flächen mit der Gemeindegrenze von Landqart.\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(tww) + \n  tm_polygons() +\n  tm_layout(title = \"TWW der Schweiz\")  +\n  tm_shape(landquart) + \n  tm_polygons(col = \"red\",border.col = \"red\")\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-14-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n::::\n\n## Übung 5.11\n\n- Verwende die Funktion `st_intersection()` um die TWW-Flächen auf die Gemeindegrenze von Landquart zu zuschneiden. \n- Visualisiere das Resultat\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntww_landquart <- st_intersection(tww, landquart)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n tm_shape(landquart) +\n  tm_borders(col = \"black\") +\n  tm_shape(tww_landquart) + \n  tm_polygons(col = \"forestgreen\") +\n  tm_layout(title = \"TWW in Landquart\")\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-16-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n::::\n\n## Input: Vektordaten selektieren\n\nMit `st_intersection` haben wir TWW Flächen verschnitten, da `st_intersetion` die Schnittmenge beider Polygone nimmt\n\n![](images/postgis-06-st-intersection.png)\n\n<!-- https://academy.vertabelo.com/course/postgis/additional-geometry-features/functions-returning-geometries/st-intersection -->\n- Alternativ können wir alle TWW Flächen selektieren, die mindestens Teilweise innerhalb des Gemeindegebietes liegen\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntww_landquart2 <- tww[landquart, ]\n```\n:::\n\n\n\n\n## Übung 5.12 \n\n- Selektiere die TWW Flächen, welche sich zumindest Teilweise in der Gemeinde Landquart befinden und speichere den Output als `tww_landquart2`\n- Visualisiere das Resultat mit `tmap`\n- Vergleiche `tww_landquart2` mit `tww_landquart`. Wie unterscheiden sich diese?\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntww_landquart2 <- tww[landquart, ]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n tm_shape(landquart) +\n  tm_borders(col = \"black\") +\n  tm_shape(tww_landquart2) + \n  tm_polygons(col = \"forestgreen\") +\n  tm_layout(title = \"TWW in Landquart\")\n```\n\n::: {.cell-output-display}\n![](uebung_5_files/figure-html/uebung-5-19-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n::::\n\n## Übung 5.13\n\n::::{.content-visible when-profile=\"musterloesung\"}\n:::{.callout-note}\n## Musterlösung\n\nExportiere `tww_landquart2` als Geopackage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(tww_landquart2, \"data-processed/tww_landquart.gpkg\", delete_layer = TRUE)\n```\n:::\n\n\n\n\n:::\n::::\n\n\n",
    "supporting": [
      "uebung_5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}